"output = {\n  constructor:function() {\n    this.radius = 6;\n    this.color = {'obstacle':'#c83232','drivable':'#3264c8','reference':'green'};\n    this.dragging = false;\n    this.editing = -1;\n    this.movingpolygon = false;\n    this.drawing = false;\n    this.startPoint = undefined;\n    this.points = [];       // Points on unclosed polygon\n    this.polygons = [];     // Closed polygons\n    this.xScale = null;\n    this.yScale = null;\n    this.drag = null;\n    this.g = null;\n    this.context = null;\n  },\n    \n  update:function() {\n    this.context.calibration.map.shapes = this.polygons;\n    this.context.calibration.__set__('map',this.context.calibration.map);\n  },\n  \n  calibrate:function(context) {\n    this.polygons = []; this.points = []\n    if (this.g) this.draw();\n    if (context.calibration.map && context.calibration.map.hasOwnProperty('shapes') ) {\n      this.polygons = context.calibration.map.shapes;\n      if (this.polygons.length > 0 && this.polygons[0].hasOwnProperty('vertices') && this.polygons[0].vertices.length > 0) {\n        console.log('First vertex:',this.polygons[0].vertices[0])\n      }\n    }\n    this.context = context;\n    if (this.g) this.draw();\n  },\n  \n  initialize:function(xScale,yScale,g) {\n    this.xScale = xScale;\n    this.yScale = yScale;\n    var thisx = this;\n    this.drag = d3.behavior.drag().on(\"drag\", function(d,i) {\n      thisx.handleDrag_points(this);\n    }).on('dragend', function(d){\n      thisx.handleDragEnd_points(this);\n    });\n    this.g = g;\n    this.draw();\n  },\n  \n  onsegment:function(p, v, w, thresh) {\n    function sqr(x) { return x * x }\n    function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }\n    var l2 = dist2(v, w);\n    if (l2 === 0) return false;\n    var thresh2 = thresh*thresh;\n    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    var tnrm = thresh/Math.sqrt(l2);\n    if (t<=tnrm || t>=(1-tnrm)) return false; // not between v and w or very close to v/w\n    return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }) < thresh2;\n  },\n  \n  polygonColor:function(poly) {\n    return this.color.hasOwnProperty(poly.type) ? this.color[poly.type] : 'gold';\n  },\n  \n  drawpoly:function(idx) {\n    var self = this;\n    if (idx >= this.polygons.length || idx < 0)\n      return;\n    var poly = this.polygons[idx]\n\n    var color = this.polygonColor(poly);\n    this.g.selectAll('g.shape_id'+poly.id).remove();\n    var g = this.g.append('g')\n      .classed('shape_id'+poly.id,true)\n      .classed('shape',true)\n      .attr('shape_id',poly.id,true);\n    g.selectAll('polygon')\n      .data([poly])\n      .enter().append('polygon')\n        .attr('points', function(d,i) { \n          return d.vertices.map(function(p) { return [self.xScale(p.x), self.yScale(p.y)]; });\n        })\n        .style('fill',color)\n        .style('fill-opacity',0.4)\n        .on('dblclick', function(d,i) {\n          var parent = d3.select(this.parentNode);\n          if (self.editing === idx) {\n            self.editing = -1;\n            parent.selectAll('circle').remove();\n          } else {\n            var current = self.editing;\n            self.editing = idx;\n            self.drawpoly(current);\n            self.drawpoly(idx);\n          }\n        })\n        .style('stroke','white');\n    \n    g.selectAll('circle').remove();  // Remove all circles\n    if (self.editing !== idx) return;\n    \n    g.selectAll('circle')\n      .data(poly.vertices)\n      .enter().append('circle')\n        .attr('cx', function(d,i) { return self.xScale(d.x); })\n        .attr('cy', function(d,i) { return self.yScale(d.y); })\n        .attr('r', this.radius)\n        .attr('fill', color)\n        .attr('stroke', '#fff')\n        .style({cursor: 'move'})\n        .on('contextmenu', function (d,i) {\n          d3.event.preventDefault();\n          d3.select(this).remove();       // Remove the circle handle\n          poly.vertices.splice(i,1);      // Remove point from vertices\n          if (poly.vertices.length<3) {   // Remove the whole polygon\n            for (var i = self.polygons.length-1; i>=0; i--) {\n              if (self.polygons[i].vertices.length < 3) {\n                self.polygons.splice(i,1);\n              }\n            }\n            g.remove();\n          } else {\n            self.drawpoly(idx);                      // Redraw because i will not match after you remove\n          }\n          self.update();\n        })\n        .call(this.drag);\n  },\n  \n  drawunfinished:function() {\n    this.g.selectAll('circle').remove();  // Remove all circles\n    this.g.select('line').remove();       // Remove the boundary of the new shape\n    this.g.select('polyline').remove();   // Remove the cursor follow line\n    if (this.points.length > 0) {\n      var polyline = this.g.append('polyline');\n      var p = [];\n      for(var i = 0; i < this.points.length; i++) {\n        var pi = [this.xScale(this.points[i].x), this.yScale(this.points[i].y)];\n        p.push(pi);\n        var circle = this.g.append('circle')\n          .attr('cx', pi[0])\n          .attr('cy', pi[1])\n          .attr('r', this.radius)\n          .attr('fill', 'white')\n          .attr('stroke', '#000')\n          .style({cursor: 'pointer'});\n      }\n      polyline.attr('points', p).style('fill', 'none').attr('stroke', '#000');\n    }\n  },\n  \n  draw:function() {\n    // Draw unfinished polygon\n    this.drawunfinished();\n\n    // Draw all finished polygons\n    this.g.selectAll('g.shape').remove();\n    for (var j = 0; j < this.polygons.length; j++) {\n      this.drawpoly(j);\n    }\n  },\n  \n  handleDragEnd_points:function(self) {\n    this.update();\n    this.dragging = false;\n  },\n  \n  handleDrag_points:function(self) {\n    if(this.drawing || this.editing<0) return;\n    this.dragging = true;\n    \n    // Get the polygon id\n    var gparent = d3.select(self.parentNode);\n    var shape_id = gparent.attr('shape_id');\n    var idx = this.editing;\n    \n    // Move this circle\n    var dragCircle = d3.select(self), newPoints = [], circle;\n    dragCircle.attr('cx', d3.event.x).attr('cy', d3.event.y);\n    \n    // Find and update the polygon\n    var x = self.getAttribute('cx');\n    var y = self.getAttribute('cy');\n    var poly = gparent.select('polygon');\n    var circles = gparent.selectAll('circle');\n    for (var i = 0; i < circles[0].length; i++) {\n      var circle = d3.select(circles[0][i]);\n      var x_ = circle.attr('cx');\n      var y_ = circle.attr('cy');\n      if ((x_===x && y_===y)) {\n        this.polygons[idx].vertices[i] = {x:this.xScale.invert(x_), y:this.yScale.invert(y_)};\n      } else if (d3.event.sourceEvent.shiftKey) {\n        x_ = parseInt(x_)+d3.event.dx;\n        y_ = parseInt(y_)+d3.event.dy;\n        this.polygons[idx].vertices[i] = {x:this.xScale.invert(x_),y:this.yScale.invert(y_)};\n        circle.attr('cx', x_);\n        circle.attr('cy', y_);\n      }\n      newPoints.push([x_+'', y_+'']);\n    }\n    poly.attr('points', newPoints);\n  },\n  \n  mouseUp:function(self, activemenu) {\n    if (!activemenu) return;\n    if (this.dragging) return;\n    var xy = {x:d3.mouse(self)[0], y:d3.mouse(self)[1]};\n    var xG = this.xScale.invert(xy.x);\n    var yG = this.yScale.invert(xy.y)\n    if (!d3.event.shiftKey) {\n      for (var i = this.polygons.length-1; i>=0; i--) {\n        var n = this.polygons[i].vertices.length;\n        for (var j = 0; j < n; j++) {\n          var p0 = (j===0) ? this.polygons[i].vertices[n-1] : this.polygons[i].vertices[j-1];\n          var p1 = this.polygons[i].vertices[j];\n          p0 = {x:this.xScale(p0.x),y:this.yScale(p0.y)};\n          p1 = {x:this.xScale(p1.x),y:this.yScale(p1.y)};\n          if (this.onsegment(xy, p0, p1, this.radius)) { // in screen coordinates\n            this.polygons[i].vertices.splice(j,0,{x:xG,y:yG});\n            this.drawpoly(i);\n            this.update();\n            return;\n          }\n        }\n      }\n    } else {\n      this.drawing = true;\n      this.startPoint = xy;\n      this.points.push({x:xG , y:yG});\n      this.drawunfinished();\n    }\n  },\n  \n  mouseMove:function(self, activemenu) {\n    if (!activemenu) return;\n    if(!this.drawing) return;\n    this.g.select('line').remove();\n    this.g.append('line')\n      .attr('x1', this.startPoint.x)\n      .attr('y1', this.startPoint.y)\n      .attr('x2', d3.mouse(self)[0] + 2)\n      .attr('y2', d3.mouse(self)[1])\n      .attr('stroke', '#53DBF3')\n      .attr('stroke-width', 1);      \n  },\n  \n  keyUp:function(self, activemenu) {\n    if (!activemenu) return;\n    var key = d3.event.keyCode;\n    if (key==16) {\n      if (this.points.length > 2) {\n        var id = math.random().toString(36).slice(2);\n        var v = this.points.splice(0);\n        var area = polygon_area.signed_area(v);\n        var typ = (area > 0) ? 'drivable' : 'obstacle';\n        this.polygons.push({'vertices':v,'id':id,'type':typ}); // move unclosed point to the closed set\n        this.update();\n        this.editing = this.polygons.length-1;\n      }\n      this.drawunfinished();\n      this.drawpoly(this.polygons.length-1);\n      this.drawing = false;\n    }\n  },\n  \n  map_request:function(msg) {\n    this.context.publishers.map_response(this.context.calibration.map);\n  },\n  \n  zoom:function(self) {\n    this.draw();\n  }\n}"