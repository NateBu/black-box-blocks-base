"output = {\n  constructor:function() {\n    this.radius = 6;\n    this.dragging = false;\n    this.drawing = -1;\n    this.paths = [];\n    this.xScale = null;\n    this.yScale = null;\n    this.drag = null;\n    this.g = null;\n    this.context = null;\n  },\n  \n  update:function() {\n    this.context.calibration.pathlist.paths = this.paths;\n    this.context.calibration.__set__('pathlist',this.context.calibration.pathlist);\n  },\n  \n  calibrate:function(context) {\n    this.context = context;\n    this.paths = (context.calibration.pathlist.hasOwnProperty('paths')) ? \n      context.calibration.pathlist.paths : [];\n    if (this.g) this.draw();\n  },\n  \n  initialize:function(xScale,yScale,g) {\n    this.xScale = xScale;\n    this.yScale = yScale;\n    var thisx = this;\n    this.drag = d3.behavior.drag().on(\"drag\", function(d,i) {\n      thisx.handleDrag_points(this);\n    }).on('dragend', function(d){\n      thisx.handleDragEnd_points(this);\n    });\n    this.g = g;\n    this.draw();\n  },\n  \n  onsegment:function(p, v, w, thresh) {\n    function sqr(x) { return x * x }\n    function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }\n    var l2 = dist2(v, w);\n    if (l2 === 0) return false;\n    var thresh2 = thresh*thresh;\n    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    var tnrm = thresh/Math.sqrt(l2);\n    if (t<=tnrm || t>=(1-tnrm)) return false; // not between v and w or very close to v/w\n    return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }) < thresh2;\n  },\n  \n  pathColor:function(poly) {\n    return 'red';\n  },\n  \n  pathHandles:function(g,path) {\n    var self = this;\n    var color = this.pathColor(path);\n    //g.selectAll('circle').remove();  // Remove all circles\n    var handles = g.selectAll('circle').data(path.vertices).enter().append('circle')\n      .attr('cx', function(d,i) { return self.xScale(d.x); })\n      .attr('cy', function(d,i) { return self.yScale(d.y); })\n      .attr('r', this.radius)\n      .attr('fill', 'red')\n      .attr('stroke', '#fff')\n      .style({cursor: 'move'})\n      .on(\"contextmenu\", function (d, i) {\n        d3.event.preventDefault();\n        d3.select(this).remove();       // Remove the circle handle\n        path.vertices.splice(i,1);      // Remove point from vertices\n        if (path.vertices.length<2) {   // Remove the whole path\n          for (var i = self.paths.length-1; i>=0; i--) {\n            if (self.paths[i].vertices.length < 2) {\n              self.paths.splice(i,1);\n              self.update()\n            }\n          }\n          g.remove();\n        } else {\n          self.draw();// Redraw because i will not match after you remove\n        }\n      })\n      .call(self.drag);\n  },\n  \n  draw:function() {\n    var self = this;\n    this.g.select('line').remove();\n    this.g.selectAll('g.path').remove();\n    for (var j = 0; j < this.paths.length; j++) {\n      var path = this.paths[j];\n      var color = this.pathColor(path);\n      this.g.selectAll('g.path_id'+path.id).remove();\n      var g = this.g.append('g')\n        .classed('path_id'+path.id,true)\n        .classed('path',true)\n        .attr('path_id',path.id,true);\n      g.selectAll('polyline')\n        .data([path])\n        .enter().append('polyline')\n          .attr('points', function(d,i) { \n            return d.vertices.map(function(p) { return [self.xScale(p.x), self.yScale(p.y)]; });\n          })\n          .style('fill','none')\n          .style('stroke','black');\n      \n      if (this.drawing == j) this.pathHandles(g,path);\n      \n    }\n  },\n  \n  handleDragEnd_points:function(self) {\n    this.update();\n    this.dragging = false;\n  },\n  \n  handleDrag_points:function(self) {\n    this.dragging = true;\n    \n    // Get the path id\n    var gparent = d3.select(self.parentNode);\n    var idx = this.drawing;  \n\n    // Move this circle\n    var dragCircle = d3.select(self), newPoints = [], circle;\n    dragCircle.attr('cx', d3.event.x).attr('cy', d3.event.y);\n    \n    // Find and update the path\n    var x = self.getAttribute('cx');\n    var y = self.getAttribute('cy');\n    var poly = gparent.select('polyline');\n    var circles = gparent.selectAll('circle');\n    for (var i = 0; i < circles[0].length; i++) {\n      var circle = d3.select(circles[0][i]);\n      var x_ = circle.attr('cx');\n      var y_ = circle.attr('cy');\n      if ((x_===x && y_===y)) {\n        this.paths[idx].vertices[i] = {x:this.xScale.invert(x_),y:this.yScale.invert(y_)};\n      } else if (d3.event.sourceEvent.shiftKey) {\n        x_ = parseInt(x_) + d3.event.dx;\n        y_ = parseInt(y_) + d3.event.dy;\n        this.paths[idx].vertices[i] = {x:this.xScale.invert(x_),y:this.yScale.invert(y_)};\n        circle.attr('cx', x_);\n        circle.attr('cy', y_);\n      }\n      newPoints.push([x_+'', y_+'']);\n    }\n    poly.attr('points', newPoints);\n  },\n  \n  mouseUp:function(self, activemenu) {\n    if (!activemenu) return;\n    if (this.dragging) return;\n    var xS = d3.mouse(self)[0]\n    var yS = d3.mouse(self)[1];\n    var xG = this.xScale.invert(xS);\n    var yG = this.yScale.invert(yS)\n    if (!d3.event.shiftKey) {\n      for (var i = this.paths.length-1; i>=0; i--) {\n        var n = this.paths[i].vertices.length;\n        for (var j = 1; j < n; j++) {\n          var p0 = this.paths[i].vertices[j-1];\n          var p1 = this.paths[i].vertices[j];\n          p0 = {x:this.xScale(p0.x),y:this.yScale(p0.y)};\n          p1 = {x:this.xScale(p1.x),y:this.yScale(p1.y)};\n          if (this.onsegment({x:xS,y:yS}, p0, p1, this.radius)) { // in screen coordinates\n            if (this.drawing === i) {\n              this.paths[i].vertices.splice(j,0,{x:xG,y:yG});\n            } else {\n              this.drawing = i;\n            }\n            this.draw();\n            this.update();\n            return;\n          }\n        }\n      }\n    } else {\n      if (this.drawing === -1) {\n        this.drawing = this.paths.length;\n        var id = math.random().toString(36).slice(2);\n        this.paths.push({'id':id,'vertices':[{x:xG,y:yG}]});\n      } else {\n        this.paths[this.drawing].vertices.push({x:xG,y:yG});\n      }\n      this.update();\n    }\n    this.draw();\n  },\n  \n  mouseMove:function(self, activemenu) {\n    if (!activemenu) return;\n    if (this.drawing < 0 || !d3.event.shiftKey) return;\n    this.g.select('line').remove();\n    var v = this.paths[this.drawing].vertices;\n    var p = v[v.length-1];\n    this.g.append('line')\n      .attr('x1', this.xScale(p.x))\n      .attr('y1', this.yScale(p.y))\n      .attr('x2', d3.mouse(self)[0] + 2)\n      .attr('y2', d3.mouse(self)[1])\n      .attr('stroke', '#53DBF3')\n      .attr('stroke-width', 1);      \n  },\n  \n  keyUp:function(self, activemenu) {\n    if (!activemenu) return;\n    var key = d3.event.keyCode;\n    if (key==16) {\n      if (this.drawing>=0 && this.paths[this.drawing].vertices.length < 2) {\n        this.paths.splice(this.drawing,1);\n        this.update();\n      }\n      this.drawing = -1;\n      this.draw();\n    }\n  },\n  \n  path_request:function(msg) {\n    this.update();\n    this.context.publishers.path_response(this.context.calibration.pathlist);\n  },\n  \n  zoom:function(self) {\n    this.draw();\n  }\n}"